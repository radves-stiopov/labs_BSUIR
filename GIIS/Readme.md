# Отчет к лабораторным работам по курсу ГИИС

# Лабораторная №1

## Условие 

![image](https://github.com/user-attachments/assets/a2b53bcc-437f-46e7-b3d9-97952b4062a4)

## Реализация

### 1. Алгоритм Брезенхема

Алгоритм Брезенхема — это эффективный способ рисования прямой линии между двумя точками на растровой сетке. Он работает, вычисляя изменения в координатах x и y и определяя, какой пиксель освещать на основе ошибки. Алгоритм использует целочисленные арифметические операции, что делает его быстрым и оптимальным для графических приложений.

- **Параметры**:
  - `start`: Начальная точка линии.
  - `end`: Конечная точка линии.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 2. Цифровой Дифференциальный Анализатор (CDA)

Алгоритм CDA используется для рисования линий, постепенно вычисляя координаты пикселей на основе градиента линии. Он делит каждую линию на заданное количество шагов, что позволяет точно контролировать положение пикселей и обеспечивает плавное рисование.

- **Параметры**:
  - `start`: Начальная точка линии.
  - `end`: Конечная точка линии.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 3. Алгоритм Ву

Алгоритм Ву — это алгоритм рисования линий с антиалиасингом, который улучшает визуальное качество линий, регулируя интенсивность пикселей в зависимости от их близости к идеальной линии. Это позволяет создавать более гладкие и эстетически приятные линии.

- **Параметры**:
  - `start`: Начальная точка линии.
  - `end`: Конечная точка линии.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.
## Скриншоты
![image](https://github.com/user-attachments/assets/132aa755-7e1a-44b6-b8d5-f6419ca94068)

![image](https://github.com/user-attachments/assets/0f976582-17b3-44bf-bd08-b2e551ea8170)





# Лабораторная №2

## Условие 
![image](https://github.com/user-attachments/assets/5282bef5-26ae-41aa-805e-b09f525fb070)


## Реализация

### 1. Алгоритм рисования окружности

Алгоритм рисования окружности использует метод Брезенхема для создания пикселей, формирующих окружность. Он работает с центром окружности и радиусом, вычисляя симметричные точки, чтобы уменьшить количество необходимых вычислений.

- **Параметры**:
  - `center`: Центр окружности.
  - `radius`: Радиус окружности.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 2. Алгоритм рисования эллипса

Алгоритм рисования эллипса также основан на методе Брезенхема, который адаптирован для работы с двумя радиусами (по горизонтали и вертикали). Он строит эллипс, используя симметричные точки для получения гладкой формы.

- **Параметры**:
  - `center`: Центр эллипса.
  - `a`: Горизонтальный радиус.
  - `b`: Вертикальный радиус.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 3. Алгоритм рисования гиперболы

Алгоритм рисования гиперболы строит кривую, используя ее фокусные свойства. Он разделяет процесс на две части, вычисляя точки для каждой ветви гиперболы и используя симметрию.

- **Параметры**:
  - `center`: Центр гиперболы.
  - `a`: Параметр, определяющий ширину гиперболы.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 4. Алгоритм рисования параболы

Алгоритм рисования параболы использует свойства параболы, чтобы определить пиксели, которые должны быть закрашены. Он работает по принципу симметрии и может быть настроен для рисования параболы, открытой вверх или вниз.

- **Параметры**:
  - `center`: Центр параболы.
  - `p`: Параметр, определяющий форму параболы.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

## Скриншоты

![image](https://github.com/user-attachments/assets/8e2a5ba1-364b-4f0e-bf93-b0c5561aecac)
![image](https://github.com/user-attachments/assets/b4ba9fcd-a571-4360-b25c-e938bd945dda)
![image](https://github.com/user-attachments/assets/9bf541d7-f081-4b86-af82-f7a8a690ceee)
![image](https://github.com/user-attachments/assets/d8c94b5c-7a33-42f8-bb6d-aec2f9544d18)





# Лабораторная №3

## Условие 
![image](https://github.com/user-attachments/assets/09a7d893-415b-490e-95a9-ff8f0c5b3337)


## Реализация

### 1. Алгоритм Эрмита (Hermite)

Алгоритм Эрмита используется для рисования кривых, задаваемых двумя точками и двумя тангенциальными векторами. Он позволяет создавать гладкие кривые, контролируя не только начальные и конечные точки, но и направление векторов в этих точках.

- **Параметры**:
  - `p1`: Первая контрольная точка.
  - `p4`: Вторая контрольная точка.
  - `r1`: Тангенциальный вектор в первой контрольной точке.
  - `r4`: Тангенциальный вектор во второй контрольной точке.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 2. Алгоритм Безье (Bezier)

Алгоритм Безье используется для создания кривых, задаваемых набором контрольных точек. Кривая Безье может быть любой степени, в зависимости от количества контрольных точек. Этот алгоритм широко используется в графике и анимации.

- **Параметры**:
  - `control_points`: Список контрольных точек для построения кривой.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

### 3. Алгоритм B-сплайна (BSpline)

Алгоритм B-сплайна позволяет создавать гладкие кривые, задаваемые контрольными точками. Он использует специальные базисные функции, которые обеспечивают более высокую гибкость и контроль над формой кривой по сравнению с кривыми Безье.

- **Параметры**:
  - `control_points`: Список контрольных точек для построения кривой.
  - `debug_mode`: Включает вывод текущих координат пикселей для отладки.

## Скриншоты
![image](https://github.com/user-attachments/assets/fcb169d9-547e-4454-8ab4-a20a9f5a4a87)
![image](https://github.com/user-attachments/assets/e87f4526-e1c7-45b6-a10a-70bb3de5d7d7)







# Лабораторная №4

## Условие 

![image](https://github.com/user-attachments/assets/130e0545-6dce-4f8a-936e-2e5aab77b562)

## Реализация

### 1. Проекционные преобразования

В классе `Object3DViewer` реализованы два типа проекций для отображения 3D-объектов: перспективная и ортографическая. 

- **Перспективная проекция**: Использует матрицу проекции, основанную на угле обзора (FOV), соотношении сторон, а также близком и дальнем планах. Объекты, находящиеся дальше, отображаются меньшими.
  
- **Ортографическая проекция**: Применяет матрицу ортографической проекции, которая не изменяет размер объектов в зависимости от расстояния, что позволяет получить более "плоское" изображение.

### 2. Преобразования объектов

Класс поддерживает несколько типов преобразований для 3D-объектов:

- **Трансляция**: Сдвигает объект в пространстве по заданным координатам (dx, dy, dz) с использованием матрицы трансляции.

- **Поворот**: Поворачивает объект вокруг выбранной оси (x, y или z) на заданный угол. Использует матрицы вращения для каждого из трех направлений.

- **Масштабирование**: Изменяет размер объекта на заданный коэффициент. Применяются матрицы масштабирования, которые изменяют размеры объекта относительно его текущего положения.

- **Отражение**: Зеркально отражает объект относительно выбранной оси (x, y или z) с использованием матриц отражения.

### 3. Загрузка и отрисовка объектов

- **Загрузка объектов**: Метод `load_object` считывает данные 3D-объекта из файла и добавляет вершины и ребра в соответствующие списки для дальнейшей отрисовки.

- **Отрисовка объектов**: Метод `draw_object` отвечает за отрисовку 3D-объектов на 2D-сцене. Он преобразует 3D-координаты вершин в 2D с использованием матриц трансформации и проекции, а затем рисует линии между вершинами, создавая видимые ребра объекта.

### 4. Рисование осей

Метод `draw_axes` создает графическое представление осей координат (X, Y, Z) в 3D-пространстве, позволяя пользователю увидеть ориентацию объектов в пространстве.

## Скриншоты
![image](https://github.com/user-attachments/assets/840c4f09-36f7-4321-bcb1-bc4318d3d512)
![image](https://github.com/user-attachments/assets/853d5e48-994b-4034-a63e-9f1d20c3552e)






# Лабораторная №5, 6

## Условие 
![image](https://github.com/user-attachments/assets/1fe97bff-6d10-434d-99c2-9af5d049b4a5)
![image](https://github.com/user-attachments/assets/76dfdc8c-3083-49f2-aff9-8b1d11f11d0c)


## Реализация


### 1. Алгоритмы заливки

#### 1.1 Простой алгоритм заливки (Simple Seed Fill)

Этот алгоритм использует метод "семени" для заливки области, начиная с указанной точки. Он проверяет соседние пиксели и заполняет их цветом, если они соответствуют исходному цвету.

- **Параметры**:
  - `x`, `y`: Координаты начальной точки заливки.
- **Принцип работы**:
  - Начинает с указанной точки и помещает её в стек.
  - Пока стек не пуст, извлекает координаты пикселя и проверяет его цвет.
  - Если цвет совпадает с целевым, пиксель заливается нужным цветом, и соседние пиксели добавляются в стек для дальнейшей проверки.

#### 1.2 Алгоритм заливки по строкам (Scanline Seed Fill)

Алгоритм заполнения, который обрабатывает пиксели по строкам. Он находит границы области и заполняет её цветом, проверяя пиксели слева и справа от начальной точки.

- **Параметры**:
  - `x`, `y`: Координаты начальной точки заливки.
- **Принцип работы**:
  - Определяет цвет пикселя в начальной точке и запоминает его.
  - Ищет границы (левую и правую) на текущей строке, пока встречает пиксели с тем же цветом.
  - Заполняет область между найденными границами и продолжает работу с соседними строками.

#### 1.3 Алгоритм активного списка рёбер (Active Edge List Fill)

Этот алгоритм использует список активных рёбер для заливки многоугольника. Он находит пересечения рёбер с горизонтальными линиями и заполняет область между ними.

- **Принципы работы**:
  - Сначала собираются все рёбра многоугольника, и для каждого из них определяется его минимальная и максимальная координаты y.
  - Рёбра сортируются по y_min.
  - Для каждой горизонтальной линии (с фиксированным y) добавляются рёбра, у которых y_min совпадает с текущим y.
  - Обрабатываются активные рёбра, вычисляются их пересечения с горизонтальной линией и заполняется область между ними.

### 2. Алгоритмы построения выпуклой оболочки

#### 2.1 Алгоритм Грэхема (Graham's Scan)

Этот алгоритм строит выпуклую оболочку, сортируя точки и используя метод "перекрестка" для определения последовательности вершин.

- **Принцип работы**:
  - Сначала сортируются точки по углу относительно стартовой точки (самой нижней).
  - Затем перебираются отсортированные точки, и для каждой из них проверяется, образует ли она правый или левый поворот с предыдущими двумя.
  - Если образуется правый поворот, предыдущая точка удаляется из оболочки.

#### 2.2 Алгоритм обёртки подарка (Jarvis March)

Алгоритм, который находит выпуклую оболочку, начиная с самой левой точки и последовательно выбирая следующую вершину, которая образует угол с предыдущими.

- **Принцип работы**:
  - Начинается с самой левой точки и добавляет её в оболочку.
  - На каждом шаге выбирается следующая точка, которая находится на максимальном угле относительно текущей точки.
  - Процесс повторяется, пока не вернётся к начальной точке.

### 3. Геометрические операции

#### 3.1 Поиск пересечений

Метод, который находит пересечения между заданной линией и рёбрами многоугольника, используя метод детерминанта для проверки пересечений.

- **Параметры**:
  - `start`: Начальная точка линии.
  - `end`: Конечная точка линии.
- **Принцип работы**:
  - Для каждой пары рёбер многоугольника проверяется, пересекаются ли они с заданной линией.
  - Используется метод детерминанта для определения, пересекаются ли два отрезка.
  - Если пересечение найдено, возвращается точка пересечения.


## Скриншоты


![image](https://github.com/user-attachments/assets/e9b557ae-cef0-43d8-879f-f7bcc3b697e9)
![image](https://github.com/user-attachments/assets/2c594e2e-27e6-491e-8d24-dde158022977)







# Лабораторная №7

## Условие 
![image](https://github.com/user-attachments/assets/1f5cc455-a6c4-4d45-a050-1a1d69ade70b)

## Реализация


### 1. Делонева триангуляция

#### 1.1 Общее описание

Алгоритм Делонева триангуляции используется для разбиения множества точек на треугольники, так что никакая точка не попадает внутрь окружности, описанной вокруг любого из треугольников. Это обеспечивает определенные свойства, такие как максимизация минимального угла треугольников.

#### 1.2 Создание супертреугольника

- **Метод**: `_create_super_triangle`
- **Принцип работы**:
  - Определяет минимальные и максимальные координаты x и y для всех точек.
  - Создает большой треугольник (супертреугольник), который полностью охватывает все точки. Это помогает в алгоритме, так как при добавлении точек этот треугольник будет удален в конце.

#### 1.3 Добавление точки

- **Метод**: `_add_point`
- **Принцип работы**:
  - Для каждой точки проверяет, попадает ли она в окружность описанного треугольника. Если да, то треугольник считается "плохим".
  - Удаляет все "плохие" треугольники и создает новые треугольники, используя границы, образованные этими треугольниками и добавленной точкой.

#### 1.4 Удаление супертреугольника

- **Метод**: `_remove_super_triangle`
- **Принцип работы**:
  - Удаляет супертреугольник и все треугольники, содержащие его вершины, из списка треугольников.

#### 1.5 Проверка, находится ли точка в окружности треугольника

- **Метод**: `_is_point_in_circumcircle`
- **Принцип работы**:
  - Вычисляет радиус окружности, описанной вокруг треугольника, и проверяет, находится ли указанная точка внутри этой окружности.

### 2. Вычисление диаграммы Вороного

#### 2.1 Общее описание

Диаграмма Вороного разбивает плоскость на области, каждая из которых соответствует одной из заданных точек. Каждая область состоит из всех точек, которые ближе к данной точке, чем к любой другой.

#### 2.2 Вычисление Вороной

- **Метод**: `compute_voronoi`
- **Принцип работы**:
  - Для каждого треугольника, созданного в процессе триангуляции, вычисляется его центр окружности (циркумцентр).
  - Находятся соседи для каждого треугольника и создаются рёбра диаграммы Вороного, используя центры окружностей.
## Скриншоты
![image](https://github.com/user-attachments/assets/0fe73490-aa64-4b80-9299-062cdce5c839)
![image](https://github.com/user-attachments/assets/e2c8b7b7-1c19-4873-93de-c4b7eecb5669)

